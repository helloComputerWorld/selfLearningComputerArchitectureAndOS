# Chapter11. CPU 스케줄링

## 11-1 CPU 스케줄링 개요

### 1. 프로세스 우선순위

- 프로세스마다 우선순위가 다름
- 우선순위가 높은 프로세스 === 빨리 처리해야 하는 프로세스
  - 대표적으로 입출력 작업이 많은 프로세스
- 입출력 집중 프로세스 vs CPU 집중 프로세스
  - 입출력 집중 프로세스
    - 입출력 작업이 많은 프로세스
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무름
  - CPU 집증 프로세스
    - CPU 작업이 많은 프로세스
- CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적
  - 입출력 집중 프로세스를 가능한 빨리 실행시키고, 그 다음 CPU 집중 프로세스에 집중적으로 할당하는 것이 . 더효율적
  - 입출력장치가 입출력 작업을 완료하기 전까지 입출력 집중 프로세스는 대기 상태가 될 예정이므로
- 차례대로 돌아가며 사용하는 것보다 상황에 맞게 배분하는 것이 더 효율적
  - 이를 위해 프로세스마다 우선순위 부여
  - 운영체제는 PCB에 우선순위를 명시하고, 우선순위를 기준으로 처리 순서 결정
  - 우선순위가 높은 프로세스가 더 빨리, 더 자주 실행됨

### 2. 스케줄링 큐

- PCB에 우선순위가 존재하지만 운영체제가 다음 프로세스를 찾기 위해 모두 찾는 것은 비효율적
- CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 스케줄링 큐로 구현하고 관리함
- 준비 큐(ready queue): CPU 이용하고 싶은 프로세스들
  - 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다림
  - 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행함
    - 우선순위가 낮은 프로세스들이 먼저 큐에 삽입되었더라도 우선순위가 높은 프로세스가 먼저 처리될 수 있음
- 대기 큐(waiting queue): 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들
  - 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다림
  - 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거함(해당 PCB는 준비 큐로 이동)

### 3. 선점형과 비선점형 스케줄링

- 선점형 스케줄링
  - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미
  - 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
  - 프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식(선점형 스케줄링의 일종)
  - 더 급한 프로세스가 언제든 끼어들어 사용할 수 있음
  - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골구로 배분할 수 있음
  - 그만큼 문맥 교환 과정(context switching)에서 오버헤드가 발생할 수 있음
  - context switching
    - CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업
    - 오버헤드: context switching에 소요되는 시간과 메모리를 의미 -> 잦은 context switching은 성능 저하 발생
- 비선점형 스케줄링
  - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미
  - 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식
  - 문맥 교환에서 발생하는 오버헤드가 선점형 스케줄링보다 적음
  - 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 기다려야 함(모든 프로세스가 골고루 자원을 사용할 수 없음)
- 현재 대부분의 운영체제는 선점형 스케줄링 방식을 차용하고 있지만, 각각 장단점 존재

## 11-2 CPU 스케줄링 알고리즘

### 1. 스케줄링 알고리즘의 종류

- 선입 선처리 스케줄링(FCFS, First Come First Served)
  - 비선점형 스케줄링 방식
  - CPU를 먼저 요청한 프로세스부터 CPU를 할당
  - CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 기다리는 방법만 존재
  - 프로세스 응답 시간의 예측이 용이, 일괄 처리 방식(Batch Processing)에 적합
    - Batch Processing: 여러 개의 프로그램을 읽어놓고, 한 번에 하나의 프로그램만 실행함
  - 단점: 짧은 작업이 긴 작업을 기다리는 경우 발생할 수 있음
    - 호위효과(convoy effect): 실행시간이 짧은 프로세스들이 실행시간이 긴 프로세스를 계속해서 기다리면서 효울성 저하 발생
- 최단 작업 우선 스케줄링(SJF, Shortest Job First)
  - 비선점형 스케줄링 방식 -> 선점형으로 구현될 수도 있음
  - 호위 효과를 방지할 수 있음
  - 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행
  - 이미 긴 프로세스가 실행중이라면 새로 도착한 짧은 프로세스는 기다리긴 해야함(비선점형 스케줄링 방식이므로)
  - 단점: 실행시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없게 됨(Starvation)
- 라운드 로빈 스케줄링(round robin)
  - 선점형 스케줄링 방식
  - FCFS 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식
  - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 방식
  - 정해진 타임 슬라이스만큼의 시간을 모두 사용하였음에도 완료되지 않았으면 다시 큐의 맨 뒤에 삽입됨(-> 이때 context switching 발생)
  - 프로세스들이 작업을 완료할 때까지 계속해서 순회함
  - 장점
    - Response time이 빨라짐
      - n 개의 프로세스가 ready queue에 있고 할당시간이 q(time quantum, 타임 슬라이스)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻음. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않음
    - 모든 프로세스가 공정하게 CPU를 할당받을 수 있음을 보장
  - 타임 슬라이스
    - 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미
    - 타임 슬라이스가 지나치게 큰 경우: FCFS와 차이가 없어짐(호위 효과 생길 여지)
    - 타임 슬라이스가 지나치게 작은 경우: context switching으로 인한 overhead가 증가 -> 프로세스를 전환하는데 발생하는 비용이 더 커짐
- 최소 잔여 시간 우선 스케줄링(SRT, Shortest Remaining Time)
  - 선점형 스케줄링 방식
  - SJT 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식
  - 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨
  - 새로운 프로세스가 도착할 때마다 새롭게 스케줄링을 진행함
  - 새로 들어온 가장 짧은 프로세스가 오자마자 실행될 수 있음
  - 단점
    - SJF와 같은 이유로 실행시간이 긴 프로세스가 영원히 CPU를 할당받을 수 없음(Starvation)
    - 새로운 프로세스가 올 때마다 스케줄링을 다시하여, 프로세스의 정확한 CPU Burst Time을 측정할 수 없음
- 우선순위 스케줄링(priority scheduling)
  - 선점, 비선점 스케줄링 방식 모두 사용 가능
    - 선점형: 더 높은 우선순위의 프로세스가 도착하면 현재 실행중인 프로세스에게서 CPU를 뺏음
    - 비선점형: 더 높은 우선순위의 프로세스가 도착하면 Ready Queue에 넣고 다음에 바로 실행되게 함
  - 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘
  - 우선순위가 같은 프로세스들은 선인 선처리로 스케줄링됨
  - SJT, SRT은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있음
    - SJT: 작업 시간이 짧은 프로세스에 높은 우선순위 부여
    - SRT: 남은 시간이 짧은 프로세스에 높은 우선수위 부여
  - 단점
    - 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들에 의해 밀려 실행될 수 없음(Starvation)
    - 해결 - Aging: 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
- 다단계 큐 스케줄링(multilevel queue scheduling)
  - 우선순위 스케줄링의 발전된 형태
  - 우선순위별로 Ready Queue를 여러 개 사용하는 스케줄링 방식
  - 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리
  - 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐
  - 큐별로 타임 슬라이스를 여러 개 지정할 수 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있음
- 다단계 피드백 큐 스케줄링(multilevel feedback queue scheduling)
  - 다단계 큐 스케줄링의 발전된 형태
  - 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없음
    - 우선순위가 낮은 프로세스는 계속 연기될 여지 존재(Starvation)
  - 이를 보완, 다단계 피드백 큐 스케줄링 -> 프로세스들이 큐 사이를 이동할 수 있음
  - 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행됨
  - 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행됨
  - 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐
  - 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 Aging 기법 적용하여 Starvation 예방 가능
  - 정리: 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 낮은 우선순위 큐에서 너무 오래 기다리면 높은 우선순위 큐로 이동시킬 수 있음
  - 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있음
